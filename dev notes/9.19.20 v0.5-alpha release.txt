v0.5 Alpha is out :)shift_map = (shift_index * modulating factor) This way instead of linearly shifting every value the same way, there's a smoothdrop off from shift_index to 0 shifting. The design I ended up settling upon for the modulating factor was a usercontrolled raised cosine window. The user can control the order and attenuationof the cosine. The way it works is like this. center_freq = midpoint between lower and higher window freq indicesif shifting freq up, the shifting index modulation is x[n] = cos(w*(n-center_freq))^order if lower_index <= n <= fftSize , 0 otherwiseif shifting downx[n] = cos(w*(n-center_freq))^order if 0 <= n <= higher_index , 0 otherwisew is calculated given the attenuation the user selects. The ideal is to havex[higher_index] and x[lower_index] = attenuation, or 	cos(w*(higher_index-center_freq)) = (attenuation)^(1/order)	w = acos(attenuation^(1/order))/(higher_index-center_freq)and then lastly, shift_map[n] = shift_index*x[n]x[n] simply provides a modulation on how far things get shiftedThis way the user can control how much frequencies beyond the window shift. Lower order / higher attenuation will mean that more values beyond the window will shift.